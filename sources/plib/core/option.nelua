
require 'plib/core/sumtype'
require 'plib/meta/concepts'
require 'plib/meta/unit_test'

-- For testing :
## require('plib.meta.unit_test')(_ENV)
require 'io'



## local make_option
## make_option = generalize(function(T)

	##[[
	local function rename_method(t, m, nm)
		if not t.metafields[m] then
			return
		end

		t.metafields[nm] = t.metafields[m]
		t.metafields[m] = nil
	end

	local function remove_method(t, m)
		static_assert(t.metafields[m], string.format("Method '%s' not found.", m))
		t.metafields[m] = nil
	end

	]]

	local T = #[T]#
	local option = #[make_option]# 

	local optionT = @sumtype(#['option(' .. tostring(T) .. ")"]#, record {
		some: T,
		none: niltype
	})

	## optionT.value.is_option = true
	## optionT.value.subtype = T

	## if T ~= primtypes.niltype then

		## rename_method(optionT.value, 'unwrap_some', 'unwrap')


		function optionT.as_ptr(self: *optionT) <polymorphic>
			if self:is_some() then
				return (@option(*T)).some(self:_unwrap_some_ptr())
			else
				return (@option(*T)).none()
			end
		end

		function optionT.expect(self: optionT, m: stringview): T
			assert(self:is_some(), m)
			return self:unwrap()
		end

		function optionT.unwrap_or(self: optionT, v: T): T
			if self:is_some() then
				return self:unwrap()
			else
				return v
			end
		end

		function optionT.unwrap_or_else(self: optionT, f: functor(T)): T
			if self:is_some() then
				return self:unwrap()
			else
				return f()
			end
		end

		function optionT.map(self: optionT, f: functor(auto, T))
			local U = #[f.type.rettypes[1]]#
			if self:is_some() then
				return (@option(U)).some(f(self:unwrap()))
			else
				return (@option(U)).none()
			end
		end

		function optionT.map_or(self: optionT, v: auto, f: functor(auto, T))
			##[[	
				static_assert(v.type == f.type.rettypes[1], 
					"The type of 'v' (" .. tostring(v.type) .. 
					") and the return type of 'f' (" .. tostring(f.type.rettypes[1]) .. 
					") aren't the same.")
			]]
			local U = #[v.type]#

			if self:is_some() then
				return f(self:unwrap())
			else
				return v
			end
		end

		function optionT.map_or_else(self: optionT, fd: functor(auto), f: functor(auto, T))
			##[[
				static_assert(fd.type.rettypes[1] == f.type.rettypes[1],
					"The return types of 'fd' (" .. tostring(fd.type.rettypes[1]) ..
					") and 'f' (" .. tostring(fd.type.rettypes[1]) .. 
					") aren't the same.")
			]]
			local U = #[fd.type.rettypes[1]]#

			if self:is_some() then
				return f(self:unwrap())
			else
				return fd()
			end
		end

		function optionT.and_(self: optionT, o: auto)
			##[[
				static_assert(o.type.is_option, "'o' isn't an option.")
			]]
			local U = #[o.type.subtype]#

			if self:is_some() then
				return o
			else
				return (@option(U)).none()
			end
		end

		function optionT.and_then(self: optionT, f: functor(auto, T))
			##[[
				static_assert(f.type.rettypes[1].is_option, "'f' doesn't return an " ..
					" option (want: function(" .. tostring(T) .. "): option(U), " .. 
					"has: " .. tostring(f.type) .. ").")
			]]
			local U = #[f.type.rettypes[1].subtype]#

			if self:is_some() then
				return f(self:unwrap())
			else
				return (@option(U)).none()
			end
		end



		function optionT.or_(self: optionT, o: optionT)
			if self:is_some() then
				return self
			else
				return o
			end
		end

		function optionT.or_else(self: optionT, f: functor(optionT))
			if self:is_some() then
				return self
			else
				return f()
			end
		end

		function optionT.xor(self: optionT, o: optionT)
			if self:is_some() and o:is_none() then
				return self
			elseif self:is_none() and o:is_none() then
				return o
			else
				return optionT.none()
			end
		end

		function optionT.get_or_insert(self: *optionT, v: T): *T
			if self:is_some() then
				return self:unwrap_some_ptr()
			else
				self:morph_into_some(v)
				return self:unwrap_some_ptr()
			end
		end

		function optionT.get_or_insert_with(self: *optionT, f: functor(T)): *T
			if self:is_some() then
				return self:unwrap_some_ptr()
			else
				self:morph_into_some(v)
				return self:unwrap_some_ptr()
			end
		end

		function optionT.take(self: *optionT): optionT
			if self:is_some() then
				local d = self:unwrap()
				self:morph_into_none()
				return optionT.some(d)
			else
				return optionT.none()
			end
		end

		function optionT.replace(self: *optionT, v: T): optionT
			if self:is_some() then
				local old = optionT.some(self:unwrap())
				self:morph_into_some(v)
				return old
			else
				self:morph_into_some(v)
				return optionT.none()
			end
		end


		##[[

		local convert_concept = concept(function(t) 
			if t.type.is_option then
				if t.type.subtype == primtypes.niltype then
					return true
				else
					local ok, err = T:is_convertible_from_type(t.type.subtype)
					if not ok then return false, err end
					return true
				end
			end

			local ok, err = T:is_convertible_from_type(t.type)
			if not ok then return false, err end
			return true
		end)

		]]

		function optionT.__convert(n: #[convert_concept]#)
			## if n.type.is_option then
				## if n.type.subtype == primtypes.niltype then
					return optionT.none()
				## else
					if n:is_some() then
						return optionT.some(n:unwrap())
					else
						return optionT.none()
					end
				## end
			## else
				return optionT.some(n)
			## end
		end

	## end


	## return optionT
## end)


global option = #[make_option]#

global function Some(v: auto)
	local T = #[v.type]#
	return (@option(T)).some(v)
end

global function None(): option(niltype)
	return (@option(niltype)).none()
end



## if TEST then

	## begin_test_suite 'plib/core/option'

		local x: option(integer) = Some(42_i)
		local y: option(integer) = None()

		## begin_test 'is_some/is_none'

			passert(x:is_some())
			passert(y:is_none())

		## begin_test 'expect'

			passert(x:expect("work") == 42)
			--passert(y:expect("panic")) -- crashes, OK

		## begin_test 'unwrap'

			passert(x:unwrap() == 42)
			--passert(y:unwrap()) -- crashes, OK

		## begin_test 'unwrap_or'

			passert(x:unwrap_or(24) == 42)
			passert(y:unwrap_or(24) == 24)

		## begin_test 'unwrap_or_else'

			local function f0(): integer
				return 24
			end

			passert(x:unwrap_or_else(f0) == 42)
			passert(y:unwrap_or_else(f0) == 24)

		## begin_test 'map'

			local function f1(v: integer): number
				return (@number)(v * 2)
			end

			passert(x:map(f1):unwrap() == 84)
			passert(y:map(f1):is_none())

		## begin_test 'map_or'

			local function f2(v: integer): integer
				return v * 2
			end

			passert(x:map_or(24, f2) == 84)
			passert(y:map_or(24, f2) == 24)

		## begin_test 'map_or_else'

			local function f3_0(): integer
				return 24
			end

			local function f3_1(v: integer): integer
				return v - 2
			end

			passert(x:map_or_else(f3_0, f3_1) == 40)
			passert(y:map_or_else(f3_0, f3_1) == 24)

		## begin_test 'and_'

			passert(x:and_(y):is_none())

		## begin_test 'and_then'

			local function f4(v: integer): option(number)
				return Some(v*10_n)
			end

			passert(x:and_then(f4):unwrap() == 420)
			passert(y:and_then(f4):is_none())

		## begin_test 'or_'

			passert(x:or_(y):unwrap() == 42)

		## begin_test 'or_else'

			local function f5(): option(integer)
				return Some(10_i)
			end

			passert(x:or_else(f5):unwrap() == 42)
			passert(y:or_else(f5):unwrap() == 10)

		## begin_test 'get_or_insert'

			passert($x:get_or_insert(10) == 42)
			passert($y:get_or_insert(10) == 10)

		## begin_test 'take'

			passert(y:take():unwrap() == 10)
			passert(y:take():is_none())

		## begin_test 'replace'

			passert(x:replace(10):unwrap() == 42)
			passert(x:unwrap() == 10)

		## begin_test 'convertion from option(T)'

			local x: option(integer) = Some(10)
			local y: option(uinteger) = x

			passert(y:is_some() and y:unwrap() == 10_n)

			local x: option(integer) = None()
			local y: option(uinteger) = x

			passert(y:is_none())


		## begin_test 'convertion from T'

			local x: option(integer) = 10

			passert(x:is_some() and x:unwrap() == 10_i)


		## begin_test 'convertion from U'

			local x: option(integer) = 10_u

			passert(x:is_some() and x:unwrap() == 10_i)


## end